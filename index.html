<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>I Ching Hexagram Calculator</title>
  <style>
    body {
      font-family: system-ui, serif;
      margin: 2rem;
      line-height: 1.5;
    }
    h1 {
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }
    label {
      display: block;
      margin-top: 0.75rem;
    }
    input[type="number"] {
      width: 4.5rem;
      padding: 0.2rem 0.3rem;
      font-size: 1rem;
    }
    fieldset {
      margin-top: 1rem;
      border: 1px solid #ccc;
      padding: 0.75rem 1rem 1rem;
    }
    legend {
      font-weight: 600;
      margin-left: 0.5rem;
      padding: 0 0.25rem;
    }
    button {
      margin-top: 1.25rem;
      padding: 0.4rem 1rem;
      font-size: 1rem;
      border: 1px solid #666;
      background: #f4f4f4;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #e5e5e5;
    }
    #results {
      margin-top: 2rem;
      border-top: 2px solid #aaa;
      padding-top: 1.5rem;
    }
    .glyph {
      font-size: 2.25rem;
      line-height: 1;
      vertical-align: middle;
    }
    pre {
      font-family: "Courier New", monospace;
      font-size: 1.15rem;
      margin: 0.5rem 0 1rem;
    }
    .moving {
      color: #c00;
      font-weight: 700;
    }
  </style>
</head>
<body>
  <h1>I Ching Hexagram Calculator</h1>
  <form id="hexForm">
    <label>
      Lower trigram (1 – 8):
      <input type="number" id="lower" min="1" max="8" required />
    </label>
    <label>
      Upper trigram (1 – 8):
      <input type="number" id="upper" min="1" max="8" required />
    </label>

    <fieldset>
      <legend>Optional draws for moving lines (bottom → top)</legend>
      <div id="drawInputs">
        <!-- six inputs generated by JS at load time -->
      </div>
      <p style="margin:0.4rem 0 0; font-size:0.9rem; color:#555;">Leave all blank if you don&rsquo;t wish to specify moving lines.</p>
    </fieldset>

    <button type="submit">Compute Hexagram</button>
  </form>

  <div id="results"></div>

<!-- ========== Core I Ching logic ========= -->
<script>
class Trigram {
  static _data = {
    1: { binary: '000', name: 'Earth',    glyph: '☷', sequence: '2' },
    2: { binary: '001', name: 'Mountain', glyph: '☶', sequence: '7' },
    3: { binary: '010', name: 'Water',    glyph: '☵', sequence: '5' },
    4: { binary: '011', name: 'Wind',     glyph: '☴', sequence: '4' },
    5: { binary: '100', name: 'Thunder',  glyph: '☳', sequence: '3' },
    6: { binary: '101', name: 'Fire',     glyph: '☲', sequence: '6' },
    7: { binary: '110', name: 'Lake',     glyph: '☱', sequence: '8' },
    8: { binary: '111', name: 'Heaven',   glyph: '☰', sequence: '1' }
  };

  constructor(index) {
    if (!Number.isInteger(index) || index < 1 || index > 8) {
      throw new RangeError('Trigram index must be an integer between 1 and 8');
    }
    this._index = index;
    this._info = Trigram._data[index];
  }

  get binaryRepresentation() {
    return this._info.binary;
  }
  get decimalBinaryValue() {
    return parseInt(this._info.binary, 2);
  }
  get name() {
    return this._info.name;
  }
  get glyph() {
    return this._info.glyph;
  }
  get sequence() {
    return this._info.sequence;
  }

  opposite() {
    const flipped = this.binaryRepresentation.replace(/[01]/g, (b) => (b === '0' ? '1' : '0'));
    const newIndex = parseInt(flipped, 2) + 1;
    return new Trigram(newIndex);
  }

  inverse() {
    const reversed = this.binaryRepresentation.split('').reverse().join('');
    const newIndex = parseInt(reversed, 2) + 1;
    return new Trigram(newIndex);
  }
}

/* ----------- 64 hexagrams lookup table ----------- */
class Hexagram {
  static _data = {
    '8,8': { textualNumber: '01', name: 'Heaven', glyph: '䷀' },
    '1,1': { textualNumber: '02', name: 'Earth', glyph: '䷁' },
    '5,3': { textualNumber: '03', name: 'Sprouting', glyph: '䷂' },
    '3,2': { textualNumber: '04', name: 'The Young Shoot', glyph: '䷃' },
    '8,3': { textualNumber: '05', name: 'Getting Wet', glyph: '䷄' },
    '3,8': { textualNumber: '06', name: 'Grievance', glyph: '䷅' },
    '3,1': { textualNumber: '07', name: 'An Army', glyph: '䷆' },
    '1,3': { textualNumber: '08', name: 'Alliance', glyph: '䷇' },
    '8,4': { textualNumber: '09', name: 'Small Restraint', glyph: '䷈' },
    '7,8': { textualNumber: '10', name: 'Treading', glyph: '䷉' },
    '8,1': { textualNumber: '11', name: 'Peace', glyph: '䷊' },
    '1,8': { textualNumber: '12', name: 'Standstill', glyph: '䷋' },
    '6,8': { textualNumber: '13', name: 'Companions', glyph: '䷌' },
    '8,6': { textualNumber: '14', name: 'Great Possessions', glyph: '䷍' },
    '2,1': { textualNumber: '15', name: 'Modesty', glyph: '䷎' },
    '1,5': { textualNumber: '16', name: 'Contentment', glyph: '䷏' },
    '5,7': { textualNumber: '17', name: 'The Chase', glyph: '䷐' },
    '4,2': { textualNumber: '18', name: 'Illness', glyph: '䷑' },
    '7,1': { textualNumber: '19', name: 'Authority Approaches', glyph: '䷒' },
    '1,4': { textualNumber: '20', name: 'Observing', glyph: '䷓' },
    '5,6': { textualNumber: '21', name: 'Biting Through', glyph: '䷔' },
    '6,2': { textualNumber: '22', name: 'Adornment', glyph: '䷕' },
    '1,2': { textualNumber: '23', name: 'Falling', glyph: '䷖' },
    '5,1': { textualNumber: '24', name: 'Return', glyph: '䷗' },
    '5,8': { textualNumber: '25', name: 'No Error', glyph: '䷘' },
    '8,2': { textualNumber: '26', name: 'Big Restraint', glyph: '䷙' },
    '5,2': { textualNumber: '27', name: 'Bulging Cheeks', glyph: '䷚' },
    '4,7': { textualNumber: '28', name: 'Big in Excess', glyph: '䷛' },
    '3,3': { textualNumber: '29', name: 'Water', glyph: '䷜' },
    '6,6': { textualNumber: '30', name: 'Fire', glyph: '䷝' },
    '2,7': { textualNumber: '31', name: 'Mutual Influence', glyph: '䷞' },
    '4,5': { textualNumber: '32', name: 'Constancy', glyph: '䷟' },
    '2,8': { textualNumber: '33', name: 'The Piglet', glyph: '䷠' },
    '8,5': { textualNumber: '34', name: 'Big Uses Force', glyph: '䷡' },
    '1,6': { textualNumber: '35', name: 'Advance', glyph: '䷢' },
    '6,1': { textualNumber: '36', name: 'The Bright Pheasant', glyph: '䷣' },
    '6,4': { textualNumber: '37', name: 'The Family', glyph: '䷤' },
    '7,6': { textualNumber: '38', name: 'Estrangement', glyph: '䷥' },
    '2,3': { textualNumber: '39', name: 'Obstruction', glyph: '䷦' },
    '3,5': { textualNumber: '40', name: 'Obstruction Removed', glyph: '䷧' },
    '7,2': { textualNumber: '41', name: 'Decrease', glyph: '䷨' },
    '5,4': { textualNumber: '42', name: 'Increase', glyph: '䷩' },
    '8,7': { textualNumber: '43', name: 'Decisive', glyph: '䷪' },
    '4,8': { textualNumber: '44', name: 'Meeting', glyph: '䷫' },
    '1,7': { textualNumber: '45', name: 'Gathering Together', glyph: '䷬' },
    '4,1': { textualNumber: '46', name: 'Pushing Upwards', glyph: '䷭' },
    '3,7': { textualNumber: '47', name: 'Burdened', glyph: '䷮' },
    '4,3': { textualNumber: '48', name: 'A Well', glyph: '䷯' },
    '6,7': { textualNumber: '49', name: 'Revolution', glyph: '䷰' },
    '4,6': { textualNumber: '50', name: 'The Ritual Caldron', glyph: '䷱' },
    '5,5': { textualNumber: '51', name: 'Thunder', glyph: '䷲' },
    '2,2': { textualNumber: '52', name: 'Mountain', glyph: '䷳' },
    '2,4': { textualNumber: '53', name: 'Gradual Advance', glyph: '䷴' },
    '7,5': { textualNumber: '54', name: 'A Maiden Marries', glyph: '䷵' },
    '6,5': { textualNumber: '55', name: 'Abundance', glyph: '䷶' },
    '2,6': { textualNumber: '56', name: 'The Traveler', glyph: '䷷' },
    '4,4': { textualNumber: '57', name: 'Wind', glyph: '䷸' },
    '7,7': { textualNumber: '58', name: 'Lake', glyph: '䷹' },
    '3,4': { textualNumber: '59', name: 'Flood', glyph: '䷺' },
    '7,3': { textualNumber: '60', name: 'Restraint', glyph: '䷻' },
    '7,4': { textualNumber: '61', name: 'Inmost Sincerity', glyph: '䷼' },
    '2,5': { textualNumber: '62', name: 'Small in Excess', glyph: '䷽' },
    '6,3': { textualNumber: '63', name: 'Already Across the River', glyph: '䷾' },
    '3,6': { textualNumber: '64', name: 'Not Yet Across the River', glyph: '䷿' }
  };

  constructor(lowerTrigram, upperTrigram, draws = null) {
    if (!(lowerTrigram instanceof Trigram) || !(upperTrigram instanceof Trigram)) {
      throw new TypeError('Both arguments must be Trigram instances');
    }
    this.lowerTrigram = lowerTrigram;
    this.upperTrigram = upperTrigram;
    const key = `${lowerTrigram._index},${upperTrigram._index}`;
    this._info = Hexagram._data[key];
    if (!this._info) {
      throw new Error(`Unknown hexagram for trigrams ${key}`);
    }
    if (draws !== null) this.setDraws(draws);
  }

  setDraws(draws) {
    if (!Array.isArray(draws) || draws.length !== 6 || !draws.every((d) => Number.isInteger(d) && d >= 1 && d <= 8)) {
      throw new RangeError('Draws must be an array of six integers from 1 to 8');
    }
    this.draws = draws;
  }

  get binaryRepresentation() {
    return this.lowerTrigram.binaryRepresentation + this.upperTrigram.binaryRepresentation;
  }
  get decimalBinaryValue() {
    return parseInt(this.binaryRepresentation, 2);
  }
  get textualNumber() {
    return this._info.textualNumber;
  }
  get name() {
    return this._info.name;
  }
  get glyph() {
    return this._info.glyph;
  }

  get lines() {
    const bits = this.binaryRepresentation.split('').map((b) => Number(b));
    return [bits[5], bits[4], bits[3], bits[2], bits[1], bits[0]];
  }

  get movingLines() {
    if (!this.draws) {
      throw new Error('Draws not set; call setDraws() first');
    }
    return this.lines.map((bit, i) => {
      const draw = this.draws[i];
      return (bit === 1 && draw <= 3) || (bit === 0 && draw === 8);
    });
  }

  target() {
    const bits = this.binaryRepresentation.split('').map((b) => Number(b));
    const mapping = { 1: 2, 2: 1, 3: 0, 4: 5, 5: 4, 6: 3 };
    const moves = this.movingLines;
    moves.forEach((isMoving, idx) => {
      if (isMoving) {
        const bitIndex = mapping[idx + 1];
        bits[bitIndex] = bits[bitIndex] === 1 ? 0 : 1;
      }
    });
    const newBin = bits.join('');
    const lowerIdx = parseInt(newBin.slice(0, 3), 2) + 1;
    const upperIdx = parseInt(newBin.slice(3), 2) + 1;
    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  _nuclearFromPattern(pattern) {
    const origLines = this.lines;
    const newBits = pattern
      .map((i) => origLines[i - 1])
      .slice()
      .reverse()
      .join('');
    const loIndex = parseInt(newBits.slice(0, 3), 2) + 1;
    const hiIndex = parseInt(newBits.slice(3), 2) + 1;
    return Hexagram.combine(new Trigram(loIndex), new Trigram(hiIndex));
  }

  nuclear() {
    return this._nuclearFromPattern([2, 3, 4, 3, 4, 5]);
  }
  secondNuclear() {
    return this._nuclearFromPattern([1, 2, 3, 2, 3, 4]);
  }
  thirdNuclear() {
    return this._nuclearFromPattern([3, 4, 5, 4, 5, 6]);
  }
  fourthNuclear() {
    return this._nuclearFromPattern([1, 2, 3, 3, 4, 5]);
  }
  fifthNuclear() {
    return this._nuclearFromPattern([2, 3, 4, 4, 5, 6]);
  }

  rotate() {
    return this._nuclearFromPattern([6, 1, 2, 3, 4, 5]);
  }

  opposite() {
    const flipped = this.binaryRepresentation.replace(/[01]/g, (b) => (b === '0' ? '1' : '0'));
    const lowerIdx = parseInt(flipped.slice(0, 3), 2) + 1;
    const upperIdx = parseInt(flipped.slice(3), 2) + 1;
    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  inverse() {
    const reversed = this.binaryRepresentation.split('').reverse().join('');
    const lowerIdx = parseInt(reversed.slice(0, 3), 2) + 1;
    const upperIdx = parseInt(reversed.slice(3), 2) + 1;
    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  static combine(lower, upper, draws = null) {
    return new Hexagram(lower, upper, draws);
  }
}
</script>

<!-- ========== App Logic & UI ========= -->
<script>
// generate six number inputs dynamically so they can be styled uniformly
(function addDrawInputs() {
  const container = document.getElementById('drawInputs');
  for (let i = 0; i < 6; i++) {
    const inp = document.createElement('input');
    inp.type = 'number';
    inp.min = '1';
    inp.max = '8';
    inp.placeholder = '–';
    inp.style.marginRight = '0.35rem';
    inp.style.marginBottom = '0.35rem';
    container.appendChild(inp);
  }
})();

// handle form submission
const form = document.getElementById('hexForm');
form.addEventListener('submit', (e) => {
  e.preventDefault();
  const lowerVal = parseInt(document.getElementById('lower').value, 10);
  const upperVal = parseInt(document.getElementById('upper').value, 10);

  if (!Number.isInteger(lowerVal) || lowerVal < 1 || lowerVal > 8 || !Number.isInteger(upperVal) || upperVal < 1 || upperVal > 8) {
    alert('Each trigram index must be an integer from 1 to 8.');
    return;
  }

  const drawInputs = document.querySelectorAll('#drawInputs input');
  const draws = Array.from(drawInputs)
    .map((inp) => parseInt(inp.value, 10))
    .filter((v) => !isNaN(v));

  if (draws.length !== 0 && draws.length !== 6) {
    alert('Please leave all draw boxes empty or fill in EXACTLY six integers (1 – 8).');
    return;
  }

  let hexagram;
  try {
    hexagram = new Hexagram(new Trigram(lowerVal), new Trigram(upperVal), draws.length === 6 ? draws : null);
  } catch (err) {
    alert(err.message);
    return;
  }

  renderResults(hexagram, draws.length === 6 ? draws : null);
});

function renderResults(hex, draws) {
  const targetDiv = document.getElementById('results');
  targetDiv.innerHTML = '';

  const heading = document.createElement('h2');
  heading.innerHTML = `Hexagram ${hex.textualNumber}: ${hex.name} <span class="glyph">${hex.glyph}</span>`;
  targetDiv.appendChild(heading);

  // basic stats
  const pMeta = document.createElement('p');
  pMeta.innerHTML = `<strong>Binary:</strong> ${hex.binaryRepresentation} &nbsp; • &nbsp; <strong>Decimal:</strong> ${hex.decimalBinaryValue}`;
  targetDiv.appendChild(pMeta);

  const pTris = document.createElement('p');
  pTris.innerHTML = `<strong>Lower:</strong> ${hex.lowerTrigram.name} ${hex.lowerTrigram.glyph} (${hex.lowerTrigram.binaryRepresentation}) &nbsp; • &nbsp; <strong>Upper:</strong> ${hex.upperTrigram.name} ${hex.upperTrigram.glyph} (${hex.upperTrigram.binaryRepresentation})`;
  targetDiv.appendChild(pTris);

  // draw lines (top line first visually)
  const pre = document.createElement('pre');
  const yangLine = '———';
  const yinLine = '— —';
  const lines = hex.lines.slice(); // bottom → top
  lines.reverse().forEach((bit, idxFromTop) => {
    const idxBottom = 5 - idxFromTop; // for moving lines index
    let lineStr = bit === 1 ? yangLine : yinLine;
    if (draws) {
      try {
        const moving = hex.movingLines[idxBottom];
        if (moving) lineStr = `<span class="moving">${lineStr}</span>`;
      } catch (err) {
        console.error(err);
      }
    }
    pre.innerHTML += lineStr + '\n';
  });
  targetDiv.appendChild(pre);

  // ─── derived hexagrams table ────────────────────────────────────────────────
  const targetHex  = draws ? hex.target() : null;

  const nuclear     = hex.nuclear();
  const secondN     = hex.secondNuclear();
  const thirdN      = hex.thirdNuclear();
  const fourthN     = hex.fourthNuclear();
  const fifthN      = hex.fifthNuclear();

  const derivedArr = [];

  if (targetHex) derivedArr.push(['Target', targetHex, true]);        // true → mark red
  derivedArr.push(
    ['Opposite',                 hex.opposite()],
    ['Inverse',                  hex.inverse()],
    ['Nuclear',                  nuclear],
    ['Second Nuclear',           secondN],
    ['Third Nuclear',            thirdN],
    ['Fourth Nuclear',           fourthN],
    ['Fifth Nuclear',            fifthN],
    ['Double Nuclear',           nuclear.nuclear()],
    ['Double Second Nuclear',    secondN.secondNuclear()],
    ['Double Third Nuclear',     thirdN.thirdNuclear()],
    ['Double Fourth Nuclear',    fourthN.fourthNuclear()],
    ['Double Fifth Nuclear',     fifthN.fifthNuclear()],
    ['Triple Fourth Nuclear',    fourthN.fourthNuclear().fourthNuclear()],
    ['Triple Fifth Nuclear',     fifthN.fifthNuclear().fifthNuclear()]
  );

  // build the table
  const table = document.createElement('table');
  table.style.borderCollapse = 'collapse';
  table.style.marginTop = '1rem';

  // header
  const headerRow = document.createElement('tr');
  ['Relation', 'No.', 'Name', 'Glyph'].forEach(text => {
    const th = document.createElement('th');
    th.textContent  = text;
    th.style.padding = '4px 8px';
    th.style.borderBottom = '1px solid #999';
    th.style.textAlign = 'left';
    headerRow.appendChild(th);
  });
  table.appendChild(headerRow);

  // rows
  derivedArr.forEach(([label, h, isTarget]) => {
    const tr = document.createElement('tr');
    if (isTarget) {
      tr.style.color = '#c00';
      tr.style.fontWeight = '700';
    }
    [label, h.textualNumber, h.name, h.glyph].forEach((val, col) => {
      const td = document.createElement('td');
      td.textContent = val;
      td.style.padding = '3px 8px';
      if (col === 3) td.style.fontSize = '1.3rem';
      tr.appendChild(td);
    });
    table.appendChild(tr);
  });

  targetDiv.appendChild(table);
}
</script>
</body>
</html>
