Look at this webapp; it allows the user to roll 2d8 to get a hexagram and then to optionally roll d8 six more times to find out whether the lines are static or moving, and what hexagram comes from that. Please write a README.md for this project.

# index.html
```
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>I Ching Hexagram Calculator</title>
  <link rel="stylesheet" href="css/styles.css">
</head>
<body>
  <h1>I Ching Hexagram Calculator</h1>
  <form id="hexForm">
    <label>
      Lower trigram (1 – 8):
      <input type="number" id="lower" min="1" max="8" required />
    </label>
    <label>
      Upper trigram (1 – 8):
      <input type="number" id="upper" min="1" max="8" required />
    </label>

    <fieldset>
      <legend>Optional draws for moving lines (bottom → top)</legend>
      <div id="drawInputs">
        <!-- six inputs generated by JS at load time -->
      </div>
      <p style="margin:0.4rem 0 0; font-size:0.9rem; color:#555;">Leave all blank if you don&rsquo;t wish to specify moving lines.</p>
    </fieldset>

    <button type="submit">Compute Hexagram</button>
  </form>

  <div id="results"></div>

<script src="js/iching-core.js"></script>
<script src="js/app.js"></script>
</body>
</html>
```

# css/styles.css

```
    body {
      font-family: system-ui, serif;
      margin: 2rem;
      line-height: 1.5;
    }
    h1 {
      font-size: 1.75rem;
      margin-bottom: 1rem;
    }
    label {
      display: block;
      margin-top: 0.75rem;
    }
    input[type="number"] {
      width: 4.5rem;
      padding: 0.2rem 0.3rem;
      font-size: 1rem;
    }
    fieldset {
      margin-top: 1rem;
      border: 1px solid #ccc;
      padding: 0.75rem 1rem 1rem;
    }
    legend {
      font-weight: 600;
      margin-left: 0.5rem;
      padding: 0 0.25rem;
    }
    button {
      margin-top: 1.25rem;
      padding: 0.4rem 1rem;
      font-size: 1rem;
      border: 1px solid #666;
      background: #f4f4f4;
      border-radius: 4px;
      cursor: pointer;
    }
    button:hover {
      background: #e5e5e5;
    }
    #results {
      margin-top: 2rem;
      border-top: 2px solid #aaa;
      padding-top: 1.5rem;
    }
    .glyph {
      font-size: 2.25rem;
      line-height: 1;
      vertical-align: middle;
    }
    pre {
      font-family: "Courier New", monospace;
      font-size: 1.15rem;
      margin: 0.5rem 0 1rem;
    }
    .moving {
      color: #c00;
      font-weight: 700;
    }
```

# js/iching-core.js

```
/* ========== Core I Ching logic ========= */
class Trigram {
  static _data = {
    1: { binary: '000', name: 'Earth',    glyph: '☷', sequence: '2' },
    2: { binary: '001', name: 'Mountain', glyph: '☶', sequence: '7' },
    3: { binary: '010', name: 'Water',    glyph: '☵', sequence: '5' },
    4: { binary: '011', name: 'Wind',     glyph: '☴', sequence: '4' },
    5: { binary: '100', name: 'Thunder',  glyph: '☳', sequence: '3' },
    6: { binary: '101', name: 'Fire',     glyph: '☲', sequence: '6' },
    7: { binary: '110', name: 'Lake',     glyph: '☱', sequence: '8' },
    8: { binary: '111', name: 'Heaven',   glyph: '☰', sequence: '1' }
  };

  constructor(index) {
    if (!Number.isInteger(index) || index < 1 || index > 8) {
      throw new RangeError('Trigram index must be an integer between 1 and 8');
    }
    this._index = index;
    this._info = Trigram._data[index];
  }

  get binaryRepresentation() {
    return this._info.binary;
  }
  get decimalBinaryValue() {
    return parseInt(this._info.binary, 2);
  }
  get name() {
    return this._info.name;
  }
  get glyph() {
    return this._info.glyph;
  }
  get sequence() {
    return this._info.sequence;
  }

  opposite() {
    const flipped = this.binaryRepresentation.replace(/[01]/g, (b) => (b === '0' ? '1' : '0'));
    const newIndex = parseInt(flipped, 2) + 1;
    return new Trigram(newIndex);
  }

  inverse() {
    const reversed = this.binaryRepresentation.split('').reverse().join('');
    const newIndex = parseInt(reversed, 2) + 1;
    return new Trigram(newIndex);
  }
}

/* ----------- 64 hexagrams lookup table ----------- */
class Hexagram {
  static _data = {
    '8,8': { textualNumber: '01', name: 'Heaven', glyph: '䷀' },
    '1,1': { textualNumber: '02', name: 'Earth', glyph: '䷁' },
    '5,3': { textualNumber: '03', name: 'Sprouting', glyph: '䷂' },
    '3,2': { textualNumber: '04', name: 'The Young Shoot', glyph: '䷃' },
    '8,3': { textualNumber: '05', name: 'Getting Wet', glyph: '䷄' },
    '3,8': { textualNumber: '06', name: 'Grievance', glyph: '䷅' },
    '3,1': { textualNumber: '07', name: 'An Army', glyph: '䷆' },
    '1,3': { textualNumber: '08', name: 'Alliance', glyph: '䷇' },
    '8,4': { textualNumber: '09', name: 'Small Restraint / Small Accumulation', glyph: '䷈' },
    '7,8': { textualNumber: '10', name: 'Treading', glyph: '䷉' },
    '8,1': { textualNumber: '11', name: 'Peace / Flowing', glyph: '䷊' },
    '1,8': { textualNumber: '12', name: 'Standstill', glyph: '䷋' },
    '6,8': { textualNumber: '13', name: 'Companions', glyph: '䷌' },
    '8,6': { textualNumber: '14', name: 'Great Possessions', glyph: '䷍' },
    '2,1': { textualNumber: '15', name: 'Modesty', glyph: '䷎' },
    '1,5': { textualNumber: '16', name: 'Contentment', glyph: '䷏' },
    '5,7': { textualNumber: '17', name: 'The Chase', glyph: '䷐' },
    '4,2': { textualNumber: '18', name: 'Illness / Decay', glyph: '䷑' },
    '7,1': { textualNumber: '19', name: 'Authority Approaches', glyph: '䷒' },
    '1,4': { textualNumber: '20', name: 'Observing', glyph: '䷓' },
    '5,6': { textualNumber: '21', name: 'Biting Through', glyph: '䷔' },
    '6,2': { textualNumber: '22', name: 'Adornment', glyph: '䷕' },
    '1,2': { textualNumber: '23', name: 'Falling', glyph: '䷖' },
    '5,1': { textualNumber: '24', name: 'Return', glyph: '䷗' },
    '5,8': { textualNumber: '25', name: 'No Error / No Expectations', glyph: '䷘' },
    '8,2': { textualNumber: '26', name: 'Big Restraint', glyph: '䷙' },
    '5,2': { textualNumber: '27', name: 'Bulging Cheeks', glyph: '䷚' },
    '4,7': { textualNumber: '28', name: 'Big in Excess', glyph: '䷛' },
    '3,3': { textualNumber: '29', name: 'Water', glyph: '䷜' },
    '6,6': { textualNumber: '30', name: 'Fire', glyph: '䷝' },
    '2,7': { textualNumber: '31', name: 'Mutual Influence', glyph: '䷞' },
    '4,5': { textualNumber: '32', name: 'Constancy', glyph: '䷟' },
    '2,8': { textualNumber: '33', name: 'The Piglet', glyph: '䷠' },
    '8,5': { textualNumber: '34', name: 'Big Uses Force', glyph: '䷡' },
    '1,6': { textualNumber: '35', name: 'Advance', glyph: '䷢' },
    '6,1': { textualNumber: '36', name: 'The Bright (Calling) Pheasant', glyph: '䷣' },
    '6,4': { textualNumber: '37', name: 'The Family', glyph: '䷤' },
    '7,6': { textualNumber: '38', name: 'Estrangement', glyph: '䷥' },
    '2,3': { textualNumber: '39', name: 'Obstruction', glyph: '䷦' },
    '3,5': { textualNumber: '40', name: 'Obstruction Removed', glyph: '䷧' },
    '7,2': { textualNumber: '41', name: 'Decrease', glyph: '䷨' },
    '5,4': { textualNumber: '42', name: 'Increase', glyph: '䷩' },
    '8,7': { textualNumber: '43', name: 'Decisive', glyph: '䷪' },
    '4,8': { textualNumber: '44', name: 'Meeting / Subjugated', glyph: '䷫' },
    '1,7': { textualNumber: '45', name: 'Gathering Together', glyph: '䷬' },
    '4,1': { textualNumber: '46', name: 'Pushing Upwards', glyph: '䷭' },
    '3,7': { textualNumber: '47', name: 'Burdened / Exhausted', glyph: '䷮' },
    '4,3': { textualNumber: '48', name: 'A Well', glyph: '䷯' },
    '6,7': { textualNumber: '49', name: 'Revolution', glyph: '䷰' },
    '4,6': { textualNumber: '50', name: 'The Ritual Caldron', glyph: '䷱' },
    '5,5': { textualNumber: '51', name: 'Thunder', glyph: '䷲' },
    '2,2': { textualNumber: '52', name: 'Mountain', glyph: '䷳' },
    '2,4': { textualNumber: '53', name: 'Gradual Advance', glyph: '䷴' },
    '7,5': { textualNumber: '54', name: 'A Maiden Marries', glyph: '䷵' },
    '6,5': { textualNumber: '55', name: 'Abundance', glyph: '䷶' },
    '2,6': { textualNumber: '56', name: 'The Traveler', glyph: '䷷' },
    '4,4': { textualNumber: '57', name: 'Wind', glyph: '䷸' },
    '7,7': { textualNumber: '58', name: 'Lake', glyph: '䷹' },
    '3,4': { textualNumber: '59', name: 'Flood / Dispersion', glyph: '䷺' },
    '7,3': { textualNumber: '60', name: 'Restraint (Regulations)', glyph: '䷻' },
    '7,4': { textualNumber: '61', name: 'Inmost Sincerity (Allegiance)', glyph: '䷼' },
    '2,5': { textualNumber: '62', name: 'Small in Excess', glyph: '䷽' },
    '6,3': { textualNumber: '63', name: 'Already Across the River', glyph: '䷾' },
    '3,6': { textualNumber: '64', name: 'Not Yet Across the River', glyph: '䷿' }
  };

  constructor(lowerTrigram, upperTrigram, draws = null) {
    if (!(lowerTrigram instanceof Trigram) || !(upperTrigram instanceof Trigram)) {
      throw new TypeError('Both arguments must be Trigram instances');
    }
    this.lowerTrigram = lowerTrigram;
    this.upperTrigram = upperTrigram;
    const key = `${lowerTrigram._index},${upperTrigram._index}`;
    this._info = Hexagram._data[key];
    if (!this._info) {
      throw new Error(`Unknown hexagram for trigrams ${key}`);
    }
    if (draws !== null) this.setDraws(draws);
  }

  setDraws(draws) {
    if (!Array.isArray(draws) || draws.length !== 6 || !draws.every((d) => Number.isInteger(d) && d >= 1 && d <= 8)) {
      throw new RangeError('Draws must be an array of six integers from 1 to 8');
    }
    this.draws = draws;
  }

  get binaryRepresentation() {
    return this.lowerTrigram.binaryRepresentation + this.upperTrigram.binaryRepresentation;
  }
  get decimalBinaryValue() {
    return parseInt(this.binaryRepresentation, 2);
  }
  get textualNumber() {
    return this._info.textualNumber;
  }
  get name() {
    return this._info.name;
  }
  get glyph() {
    return this._info.glyph;
  }

  /** @returns {number[]} six bits [line 1 … line 6] where
   *  index 0 = bottom line, index 5 = top line
   */
  get lines() {
    const lo = this.lowerTrigram.binaryRepresentation; // dataset is bottom→top
    const up = this.upperTrigram.binaryRepresentation;
    return [
      Number(lo[0]), Number(lo[1]), Number(lo[2]),   // lower trigram
      Number(up[0]), Number(up[1]), Number(up[2])    // upper trigram
    ];
  }

  get movingLines() {
    if (!this.draws) {
      throw new Error('Draws not set; call setDraws() first');
    }
    return this.lines.map((bit, i) => {
      const draw = this.draws[i];
      return (bit === 1 && draw <= 3) || (bit === 0 && draw === 8);
    });
  }

  /**
   * Return the hexagram obtained after all moving lines flip.
   * Requires six draws to have been set.
   */
  target() {
    if (!this.draws) {
      throw new Error('Draws not set; call setDraws() first');
    }

    // flip every line that is “moving”
    const flipped = this.lines.map((bit, i) =>
      this.movingLines[i] ? 1 - bit : bit
    ); // bottom → top

    /* rebuild each trigram’s 3-bit string
       — dataset stores bits bottom→top                              */
    const lowerBits = '' + flipped[0] + flipped[1] + flipped[2];
    const upperBits = '' + flipped[3] + flipped[4] + flipped[5];

    const lowerIdx = parseInt(lowerBits, 2) + 1;
    const upperIdx = parseInt(upperBits, 2) + 1;

    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  _nuclearFromPattern(pattern) {
    const origLines = this.lines;
    const newBits = pattern
      .map((i) => origLines[i - 1])
      .slice()
      .reverse()
      .join('');
    const loIndex = parseInt(newBits.slice(0, 3), 2) + 1;
    const hiIndex = parseInt(newBits.slice(3), 2) + 1;
    return Hexagram.combine(new Trigram(loIndex), new Trigram(hiIndex));
  }

  nuclear() {
    return this._nuclearFromPattern([2, 3, 4, 3, 4, 5]);
  }
  secondNuclear() {
    return this._nuclearFromPattern([1, 2, 3, 2, 3, 4]);
  }
  thirdNuclear() {
    return this._nuclearFromPattern([3, 4, 5, 4, 5, 6]);
  }
  fourthNuclear() {
    return this._nuclearFromPattern([1, 2, 3, 3, 4, 5]);
  }
  fifthNuclear() {
    return this._nuclearFromPattern([2, 3, 4, 4, 5, 6]);
  }

  /* ───── line-level helpers ───────────────────────────── */

  /** Return `true` if the given 1-based line number is “correct”. */
  isCorrect(lineNo) {
    const bit = this.lines[lineNo - 1];                 // 0 = yin, 1 = yang
    return (lineNo % 2 === 1) ? bit === 1               // 1,3,5 ⇒ yang
                              : bit === 0;              // 2,4,6 ⇒ yin
  }

  /** Lines whose current state is correct.  */
  correctLines()   { return [1,2,3,4,5,6].filter(n => this.isCorrect(n)); }

  /** Lines whose current state is *not* correct. */
  incorrectLines() { return [1,2,3,4,5,6].filter(n => !this.isCorrect(n)); }

  /** Successive-line pairs and whether they “hold together”.       */
  holdingPairs() {
    return Array.from({ length: 5 }, (_, i) => {
      const a = i + 1, b = i + 2;
      return { a, b, holds: this.lines[i] !== this.lines[i + 1] };
    });
  }

  /** (1,4) (2,5) (3,6) pairs and whether they correspond.          */
  correspondencePairs() {
    return [0,1,2].map(i => {
      const a = i + 1, b = i + 4;
      return { a, b, corresponds: this.lines[i] !== this.lines[i + 3] };
    });
  }


  /**
   * Barber-pole rotation (new rule)
   * – Move line 6 (the top line) to line 1 (the bottom line),
   *   and shift every other line up by one position.
   *
   *   Example 111010 → 011101
   */
  rotate() {
    // bits[0] = line 1 (bottom) … bits[5] = line 6 (top)
    const bits = this.binaryRepresentation.split('').map(b => +b);

    // Move the top line to the bottom.
    const shifted = [bits[5], ...bits.slice(0, 5)];

    // Re-create the 6-bit string, still in bottom→top order.
    const newBin = shifted.join('');

    // Re-build the two trigrams.
    const lowerIdx = parseInt(newBin.slice(0, 3), 2) + 1; // +1 because indices run 1-8
    const upperIdx = parseInt(newBin.slice(3), 2) + 1;

    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  
  /** Return the rotation-cycle until we’re back at this hexagram */
  cycle() {
    const cycle = [this];
    let next = this.rotate();
    while (next.decimalBinaryValue !== this.decimalBinaryValue) {
      cycle.push(next);
      next = next.rotate();
    }
    return cycle;          // e.g. length 1, 2, 3 or 6
  }

  opposite() {
    const flipped = this.binaryRepresentation.replace(/[01]/g, (b) => (b === '0' ? '1' : '0'));
    const lowerIdx = parseInt(flipped.slice(0, 3), 2) + 1;
    const upperIdx = parseInt(flipped.slice(3), 2) + 1;
    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  inverse() {
    const reversed = this.binaryRepresentation.split('').reverse().join('');
    const lowerIdx = parseInt(reversed.slice(0, 3), 2) + 1;
    const upperIdx = parseInt(reversed.slice(3), 2) + 1;
    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  /**
   * Flip the given 1-based line positions (1 = bottom, 6 = top)
   * and return the new Hexagram.
   * @param {number[]} indices
   * @private
   */
  _flipLines(indices) {
    // bits[0] is bottom-most binary bit, bits[5] is top-most
    const bits = this.binaryRepresentation.split('').map(b => (b === '1' ? 1 : 0));
    indices.forEach(i => {
      const bitIdx = 6 - i;            // map line position → bit index
      bits[bitIdx] ^= 1;               // flip 0↔1
    });
    const newBin   = bits.join('');
    const lowerIdx = parseInt(newBin.slice(0, 3), 2) + 1;
    const upperIdx = parseInt(newBin.slice(3),    2) + 1;
    return Hexagram.combine(new Trigram(lowerIdx), new Trigram(upperIdx));
  }

  /**
   * “Flower” : hexagrams obtained by flipping each single line.
   * – antecedents: flip a 0→1 (yin→yang) line
   * – consequents: flip a 1→0 (yang→yin) line
   * @returns {{ antecedents: Hexagram[], consequents: Hexagram[] }}
   */
  flower() {
    const antecedents = [];
    const consequents = [];
    // this.lines is [line1…line6]  (1 = bottom)
    this.lines.forEach((bit, idx) => {
      const petal = this._flipLines([idx + 1]);   // flip just this line
      if (bit === 0) {
        antecedents.push(petal);   // was yin → became yang
      } else {
        consequents.push(petal);   // was yang → became yin
      }
    });
    return { antecedents, consequents };
  }
  
  /**
   * “Story” sequence:
   *   0: original
   *   1‒6: flip lines 1…k
   *   7‒11: flip lines k…6  (k = 2…6)
   *   12: back to original
   * @returns {Hexagram[]}
   */
  story() {
    const seq = [this];

    // forward: flip [1..k]
    for (let k = 1; k <= 6; k++) {
      seq.push(this._flipLines(Array.from({ length: k }, (_, i) => i + 1)));
    }

    // backward: flip [k..6]
    for (let k = 2; k <= 6; k++) {
      const len = 7 - k;          // so k … 6 inclusive
      seq.push(this._flipLines(Array.from({ length: len }, (_, i) => k + i)));
    }

    // close the loop
    seq.push(this);
    return seq;
  }
  
  static combine(lower, upper, draws = null) {
    return new Hexagram(lower, upper, draws);
  }
}
```

# app.js

```
/* ========== App Logic & UI ========= */
// generate six number inputs dynamically so they can be styled uniformly
(function addDrawInputs() {
  const container = document.getElementById('drawInputs');
  for (let i = 0; i < 6; i++) {
    const inp = document.createElement('input');
    inp.type = 'number';
    inp.min = '1';
    inp.max = '8';
    inp.placeholder = '–';
    inp.style.marginRight = '0.35rem';
    inp.style.marginBottom = '0.35rem';
    container.appendChild(inp);
  }
})();

// handle form submission
const form = document.getElementById('hexForm');
form.addEventListener('submit', (e) => {
  e.preventDefault();
  const lowerVal = parseInt(document.getElementById('lower').value, 10);
  const upperVal = parseInt(document.getElementById('upper').value, 10);

  if (!Number.isInteger(lowerVal) || lowerVal < 1 || lowerVal > 8 || !Number.isInteger(upperVal) || upperVal < 1 || upperVal > 8) {
    alert('Each trigram index must be an integer from 1 to 8.');
    return;
  }

  const drawInputs = document.querySelectorAll('#drawInputs input');
  const draws = Array.from(drawInputs)
    .map((inp) => parseInt(inp.value, 10))
    .filter((v) => !isNaN(v));

  if (draws.length !== 0 && draws.length !== 6) {
    alert('Please leave all draw boxes empty or fill in EXACTLY six integers (1 – 8).');
    return;
  }

  let hexagram;
  try {
    hexagram = new Hexagram(new Trigram(lowerVal), new Trigram(upperVal), draws.length === 6 ? draws : null);
  } catch (err) {
    alert(err.message);
    return;
  }

  renderResults(hexagram, draws.length === 6 ? draws : null);
});

function renderResults(hex, draws) {
  const targetDiv = document.getElementById('results');
  targetDiv.innerHTML = '';

  const heading = document.createElement('h2');
  heading.innerHTML = `Hexagram ${hex.textualNumber}: ${hex.name} <span class="glyph">${hex.glyph}</span>`;
  targetDiv.appendChild(heading);

  // basic stats
  const pMeta = document.createElement('p');
  pMeta.innerHTML = `<strong>Binary:</strong> ${hex.binaryRepresentation} &nbsp; • &nbsp; <strong>Decimal:</strong> ${hex.decimalBinaryValue}`;
  targetDiv.appendChild(pMeta);

  const pTris = document.createElement('p');
  pTris.innerHTML = `<strong>Lower:</strong> ${hex.lowerTrigram.name} ${hex.lowerTrigram.glyph} (${hex.lowerTrigram.binaryRepresentation}) &nbsp; • &nbsp; <strong>Upper:</strong> ${hex.upperTrigram.name} ${hex.upperTrigram.glyph} (${hex.upperTrigram.binaryRepresentation})`;
  targetDiv.appendChild(pTris);

  // ─── line diagram + per-line commentary ──────────────────────────────────
  const roles   = [
    'Common-Man',          // line 1  (bottom)
    'The Great Official',  // line 2
    'Transitional',        // line 3
    'Minister/Advisor',    // line 4
    'The Ruler',           // line 5
    'The Sage'             // line 6  (top)
  ];

  const pre  = document.createElement('pre');
  const yang = '———';
  const yin  = '— —';

  for (let i = 5; i >= 0; i--) {            // i = 5 (top) … 0 (bottom)
    const bit       = hex.lines[i];                 // 0 = yin, 1 = yang
    const moving    = draws ? hex.movingLines[i] : false;
    const targetBit = moving ? 1 - bit : bit;       // after flip, if any

    const glyph     = bit === 1 ? yang : yin;
    const nowStr    = bit       === 1 ? 'Strong' : 'Weak';
    const thenStr   = targetBit === 1 ? 'Strong' : 'Weak';
    const arrow     = moving ? ` → ${thenStr}` : '';

    const lineNo    = i + 1;                        // 1 … 6
    const textRow   = `${glyph}  Line ${lineNo} – ${roles[i]} – ${nowStr}${arrow}`;

    pre.innerHTML += moving
        ? `<span class="moving">${textRow}</span>\n`
        : `${textRow}\n`;
  }

  targetDiv.appendChild(pre);

  // ─── Line information section ───────────────────────────────────────────
  const infoDiv = document.createElement('div');
  infoDiv.style.margin = '1rem 0';

  const hInfo = document.createElement('h3');
  hInfo.textContent = 'Line information:';
  infoDiv.appendChild(hInfo);

  /* ----- Correctness ----- */
  const pCorr = document.createElement('p');
  pCorr.innerHTML =
    '<strong>Correct lines:</strong> '   +
    (hex.correctLines().join(', ')   || 'None') +
    '<br><strong>Incorrect lines:</strong> ' +
    (hex.incorrectLines().join(', ') || 'None');
  infoDiv.appendChild(pCorr);

  /* ----- Holding together ----- */
  const pHold = document.createElement('p');
  pHold.innerHTML = '<strong>Holding together:</strong><br>' +
    hex.holdingPairs().map(p =>
      `Line ${p.a} ${p.holds ? 'holds together with' : 'does not hold together with'} line ${p.b}`
    ).join('<br>');
  infoDiv.appendChild(pHold);

  /* ----- Correspondence ----- */
  const pCorrsp = document.createElement('p');
  pCorrsp.innerHTML = '<strong>Correspondence:</strong><br>' +
    hex.correspondencePairs().map(p =>
      `Line ${p.a} ${p.corresponds ? 'corresponds with' : 'does not correspond with'} line ${p.b}`
    ).join('<br>');
  infoDiv.appendChild(pCorrsp);

  targetDiv.appendChild(infoDiv);

  // ─── derived hexagrams table ────────────────────────────────────────────────
  const targetHex  = draws ? hex.target() : null;

  const nuclear     = hex.nuclear();
  const secondN     = hex.secondNuclear();
  const thirdN      = hex.thirdNuclear();
  const fourthN     = hex.fourthNuclear();
  const fifthN      = hex.fifthNuclear();

  const derivedArr = [];

  if (targetHex) derivedArr.push(['Target', targetHex, true]);        // true → mark red
  derivedArr.push(
    ['Opposite',                 hex.opposite()],
    ['Inverse',                  hex.inverse()],
    ['Nuclear',                  nuclear],
    ['Second Nuclear',           secondN],
    ['Third Nuclear',            thirdN],
    ['Fourth Nuclear',           fourthN],
    ['Fifth Nuclear',            fifthN],
    ['Double Nuclear',           nuclear.nuclear()],
    ['Double Second Nuclear',    secondN.secondNuclear()],
    ['Double Third Nuclear',     thirdN.thirdNuclear()],
    ['Double Fourth Nuclear',    fourthN.fourthNuclear()],
    ['Double Fifth Nuclear',     fifthN.fifthNuclear()],
    ['Triple Fourth Nuclear',    fourthN.fourthNuclear().fourthNuclear()],
    ['Triple Fifth Nuclear',     fifthN.fifthNuclear().fifthNuclear()]
  );

  //heading
  const tableHeading = document.createElement('h3');
  tableHeading.textContent = 'Derived Hexagrams';
  tableHeading.style.marginTop = '1.5rem';
  tableHeading.style.marginBottom = '0.5rem';
  targetDiv.appendChild(tableHeading);

  // build the table
  const table = document.createElement('table');
  table.style.borderCollapse = 'collapse';
  table.style.marginTop = '1rem';

  // header
  const headerRow = document.createElement('tr');
  ['Relation', 'No.', 'Name', 'Glyph'].forEach(text => {
    const th = document.createElement('th');
    th.textContent  = text;
    th.style.padding = '4px 8px';
    th.style.borderBottom = '1px solid #999';
    th.style.textAlign = 'left';
    headerRow.appendChild(th);
  });
  table.appendChild(headerRow);

  // rows
  derivedArr.forEach(([label, h, isTarget]) => {
    const tr = document.createElement('tr');
    if (isTarget) {
      tr.style.color = '#c00';
      tr.style.fontWeight = '700';
    }
    [label, h.textualNumber, h.name, h.glyph].forEach((val, col) => {
      const td = document.createElement('td');
      td.textContent = val;
      td.style.padding = '3px 8px';
      if (col === 3) td.style.fontSize = '1.3rem';
      tr.appendChild(td);
    });
    table.appendChild(tr);
  });

  targetDiv.appendChild(table);
  
  // ─── rotation-cycle table ──────────────────────────────────────────────────
  const cycleArr = hex.cycle();     // [this, …]

  const cycHeading = document.createElement('h3');
  cycHeading.textContent = 'Rotation Cycle';
  cycHeading.style.marginTop = '1.8rem';
  targetDiv.appendChild(cycHeading);

  const cycTable = document.createElement('table');
  cycTable.style.borderCollapse = 'collapse';
  cycTable.style.marginTop = '0.4rem';

  // header
  const headRow = document.createElement('tr');
  ['Step', 'No.', 'Name', 'Glyph'].forEach(label => {
    const th = document.createElement('th');
    th.textContent = label;
    th.style.padding = '4px 8px';
    th.style.borderBottom = '1px solid #999';
    th.style.textAlign = 'left';
    headRow.appendChild(th);
  });
  cycTable.appendChild(headRow);

  // rows
  cycleArr.forEach((h, idx) => {
    const tr = document.createElement('tr');
    if (idx === 0) {           // the starting hexagram
      tr.style.fontWeight = '700';
    }
    [idx + 1, h.textualNumber, h.name, h.glyph].forEach((val, col) => {
      const td = document.createElement('td');
      td.textContent = val;
      td.style.padding = '3px 8px';
      if (col === 3) td.style.fontSize = '1.3rem';
      tr.appendChild(td);
    });
    cycTable.appendChild(tr);
  });

  targetDiv.appendChild(cycTable);
  
  // ─── flower (antecedents & consequents) ─────────────────────────────────────
  const { antecedents, consequents } = hex.flower();

  // header
  const flowerHeader = document.createElement('h3');
  flowerHeader.textContent = 'Flower';
  flowerHeader.style.marginTop = '1.4rem';
  targetDiv.appendChild(flowerHeader);

  // build flower table
  const flTable = document.createElement('table');
  flTable.style.borderCollapse = 'collapse';
  flTable.style.marginTop = '0.5rem';

  // header row
  const flHead = document.createElement('tr');
  ['Type', 'No.', 'Name', 'Glyph'].forEach(text => {
    const th = document.createElement('th');
    th.textContent = text;
    th.style.padding = '4px 8px';
    th.style.borderBottom = '1px solid #999';
    th.style.textAlign = 'left';
    flHead.appendChild(th);
  });
  flTable.appendChild(flHead);

  // helper to add rows
  function addPetalRows(list, kind) {
    list.forEach(h => {
      const tr = document.createElement('tr');
      [kind, h.textualNumber, h.name, h.glyph].forEach((val, col) => {
        const td = document.createElement('td');
        td.textContent = val;
        td.style.padding = '3px 8px';
        if (col === 3) td.style.fontSize = '1.3rem';
        tr.appendChild(td);
      });
      flTable.appendChild(tr);
    });
  }

  addPetalRows(antecedents, 'Antecedent');
  addPetalRows(consequents, 'Consequent');

  targetDiv.appendChild(flTable);
    
  // ─── story (narrative sequence) ────────────────────────────────────────────
  const storyArr = hex.story();

  // header
  const storyHeader = document.createElement('h3');
  storyHeader.textContent = 'Story';
  storyHeader.style.marginTop = '1.4rem';
  targetDiv.appendChild(storyHeader);

  // build table
  const stTable = document.createElement('table');
  stTable.style.borderCollapse = 'collapse';
  stTable.style.marginTop = '0.5rem';

  // header row
  const stHead = document.createElement('tr');
  ['Step', 'No.', 'Name', 'Glyph'].forEach(text => {
    const th = document.createElement('th');
    th.textContent  = text;
    th.style.padding = '4px 8px';
    th.style.borderBottom = '1px solid #999';
    th.style.textAlign = 'left';
    stHead.appendChild(th);
  });
  stTable.appendChild(stHead);

  // rows
  storyArr.forEach((h, idx) => {
    const tr = document.createElement('tr');
    [idx, h.textualNumber, h.name, h.glyph].forEach((val, col) => {
      const td = document.createElement('td');
      td.textContent = val;
      td.style.padding = '3px 8px';
      if (col === 3) td.style.fontSize = '1.3rem';
      tr.appendChild(td);
    });
    stTable.appendChild(tr);
  });

  targetDiv.appendChild(stTable);
}
```